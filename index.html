<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://pbs.twimg.com/profile_images/1950061433796120576/TG_biQfc_400x400.png" type="image/png">
    <title>Solana Batch Transfer Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <script>
        // Tailwind Config
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#9945FF', // Solana Purple
                        secondary: '#14F195', // Solana Green
                        danger: '#ef4444',
                        darkbg: '#0f172a',
                        cardbg: '#1e293b'
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }
    </style>
</head>
<body class="bg-darkbg text-gray-200 font-sans min-h-screen flex flex-col" 
      style="background-image: linear-gradient(rgba(15, 23, 42, 0.8), rgba(15, 23, 42, 0.8)), url('https://pbs.twimg.com/profile_banners/1802533132006301696/1765355404/1500x500'); background-size: cover; background-position: center; background-attachment: fixed;">

    <!-- Header -->
    <header class="bg-cardbg border-b border-gray-700 p-4 shadow-lg">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold text-primary flex items-center gap-2">
                <!-- Solana Logo (Simple SVG) -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 397 311" fill="none">
                    <path d="M64.6 237.9c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7zm0-160.1c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7c-2.4 2.4-5.7 3.8-9.2 3.8H6.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7zm267.3 78.6c-2.4 2.4-5.7 3.8-9.2 3.8H5.5c-5.8 0-8.7-7-4.6-11.1l62.7-62.7c2.4-2.4 5.7-3.8 9.2-3.8h317.4c5.8 0 8.7 7 4.6 11.1l-62.7 62.7z" fill="url(#paint0_linear)"/>
                    <defs>
                        <linearGradient id="paint0_linear" x1="198.7" y1="0" x2="198.7" y2="310.6" gradientUnits="userSpaceOnUse">
                            <stop stop-color="#9945FF"/>
                            <stop offset="1" stop-color="#14F195"/>
                        </linearGradient>
                    </defs>
                </svg>
                Solana Batch Transfer
            </h1>
            <div class="flex items-center gap-4">
                <div class="text-sm text-gray-400 hidden md:block">
                    Secure & Local Execution
                </div>
                <a href="https://x.com/AxinSpark" target="_blank" class="flex items-center gap-2 bg-gray-800 hover:bg-gray-700 px-3 py-1.5 rounded-full border border-gray-600 transition-colors group">
                    <img src="https://pbs.twimg.com/profile_images/1950061433796120576/TG_biQfc_400x400.png" alt="AxinSpark" class="w-6 h-6 rounded-full border border-gray-500">
                    <div class="flex flex-col">
                        <span class="text-[10px] text-gray-500 group-hover:text-blue-400 leading-none mb-0.5">Author</span>
                        <span class="text-xs font-bold text-gray-200 group-hover:text-white leading-none">@AxinSpark</span>
                    </div>
                </a>
            </div>
        </div>
    </header>

    <main class="flex-grow max-w-7xl mx-auto w-full p-4 space-y-6">

        <!-- Safety Disclaimer -->
        <div class="bg-red-900/20 border border-red-500/50 rounded-lg p-4 flex items-start gap-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-red-500 flex-shrink-0 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <div>
                <h3 class="font-bold text-red-400">安全免责声明</h3>
                <p class="text-sm text-gray-300 mt-1">
                    本工具是一个纯前端应用，所有私钥仅在您的浏览器本地处理，绝不会发送到任何外部服务器。
                    代码完全开源透明。使用前请务必核对接收地址，因私钥泄露或操作失误导致的资产损失，开发者概不负责。
                    建议在使用大额资产前，先用小额资金进行测试。
                </p>
            </div>
        </div>

        <!-- Configuration -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-cardbg p-4 rounded-lg border border-gray-700">
                <label class="block text-sm font-medium text-gray-400 mb-1">选择网络 (Network)</label>
                <select id="networkSelect" onchange="onNetworkChange()" 
                    class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary mb-3">
                    <option value="mainnet">Solana Mainnet</option>
                    <option value="custom">Custom RPC (自定义)</option>
                </select>

                <label class="block text-sm font-medium text-gray-400 mb-1 flex justify-between">
                    <span>RPC 节点地址</span>
                    <span class="text-xs text-gray-500">
                        <a href="https://www.alchemy.com/" target="_blank" class="text-primary hover:underline">申请免费主网RPC (Alchemy)</a>
                    </span>
                </label>
                <input type="text" id="rpcUrl" value="https://solana-mainnet.g.alchemy.com/v2/MSfS3EuDwErM0Ruv46cOO" oninput="restartRpcMonitor()"
                    class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary placeholder-gray-500"
                    placeholder="例如: https://solana-mainnet.g.alchemy.com/v2/...">
                
                <!-- RPC Status Monitor -->
                <div class="mt-2 flex items-center gap-4 text-xs bg-gray-800/50 p-2 rounded border border-gray-700/50">
                    <div id="rpcStatus" class="flex items-center gap-1.5 text-gray-500 font-medium">
                        <span class="w-2 h-2 rounded-full bg-gray-500"></span>
                        <span>检测中...</span>
                    </div>
                    <div id="rpcLatency" class="hidden font-mono"></div>
                    <div id="rpcHeight" class="hidden font-mono text-gray-400"></div>
                </div>
            </div>
            <div class="bg-cardbg p-4 rounded-lg border border-gray-700 relative">
                <label class="block text-sm font-medium text-gray-400 mb-1">代币合约地址 (可选)</label>
                <input type="text" id="tokenAddress" oninput="checkTokenInfo()"
                    class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary placeholder-gray-500"
                    placeholder="输入SPL Token地址 (留空则转账SOL)">
                <div id="tokenInfo" class="mt-2 text-xs text-gray-400 hidden flex items-center gap-2">
                    <span class="w-2 h-2 rounded-full bg-green-500"></span>
                    <span id="tokenDecimals">Decimals: -</span>
                </div>
                <p class="text-xs text-gray-500 mt-2">留空默认转账原生 SOL。输入 Token 地址则转账对应代币。</p>
            </div>
        </div>

        <!-- Main Interface -->
        <div class="bg-cardbg rounded-lg border border-gray-700 shadow-xl overflow-hidden">
            <!-- Tabs -->
            <div class="flex border-b border-gray-700">
                <button onclick="switchTab('mn')" id="tab-mn" class="flex-1 py-4 text-center font-medium hover:bg-gray-700 transition-colors border-b-2 border-primary text-primary">
                    功能一：多对多 (M:N)
                </button>
                <button onclick="switchTab('m1')" id="tab-m1" class="flex-1 py-4 text-center font-medium hover:bg-gray-700 transition-colors text-gray-400 border-b-2 border-transparent">
                    功能二：归集 (M:1)
                </button>
                <button onclick="switchTab('1n')" id="tab-1n" class="flex-1 py-4 text-center font-medium hover:bg-gray-700 transition-colors text-gray-400 border-b-2 border-transparent">
                    功能三：分发 (1:N)
                </button>
            </div>

            <div class="p-6">
                <!-- Mode M:N -->
                <div id="panel-mn" class="space-y-4">
                    <div class="bg-blue-900/20 p-3 rounded border border-blue-500/30 text-sm text-blue-300 mb-4">
                        <span class="font-bold">模式说明：</span> 第1个私钥转给第1个地址，第2个转给第2个... 行数必须对应。
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">批量私钥 (每行一个)</label>
                            <textarea id="mn-keys" rows="10" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-xs focus:outline-none focus:border-primary" placeholder="支持格式: Base58 (5Mikk...), Hex (1e9e...), 或 JSON Array ([1,2...])"></textarea>
                            <button onclick="verifyKeys('mn-keys')" class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 text-primary text-sm rounded transition-colors flex justify-center items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                </svg>
                                确认导入并查看余额
                            </button>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">批量接收地址 (每行一个)</label>
                            <textarea id="mn-addrs" rows="10" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-xs focus:outline-none focus:border-primary" placeholder="Solana地址 (Base58)"></textarea>
                            <button onclick="verifyMnMapping()" class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 text-secondary text-sm rounded transition-colors flex justify-center items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                确认导入接收地址
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Mode M:1 -->
                <div id="panel-m1" class="space-y-4 hidden">
                    <div class="bg-blue-900/20 p-3 rounded border border-blue-500/30 text-sm text-blue-300 mb-4">
                        <span class="font-bold">模式说明：</span> 所有输入的私钥账户将资金转入同一个接收地址。
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">批量私钥 (每行一个)</label>
                            <textarea id="m1-keys" rows="10" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-xs focus:outline-none focus:border-primary" placeholder="支持格式: Base58 (5Mikk...), Hex (1e9e...), 或 JSON Array ([1,2...])"></textarea>
                            <button onclick="verifyKeys('m1-keys')" class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 text-primary text-sm rounded transition-colors flex justify-center items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                </svg>
                                确认导入并查看余额
                            </button>
                        </div>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-400 mb-2">接收地址 (单个)</label>
                                <input type="text" id="m1-addr" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-sm focus:outline-none focus:border-primary" placeholder="Solana地址 (Base58)">
                                <button onclick="verifyM1Mapping()" class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 text-secondary text-sm rounded transition-colors flex justify-center items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                    </svg>
                                    确认导入接收地址
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Mode 1:N -->
                <div id="panel-1n" class="space-y-4 hidden">
                    <div class="bg-blue-900/20 p-3 rounded border border-blue-500/30 text-sm text-blue-300 mb-4">
                        <span class="font-bold">模式说明：</span> 一个主账户向多个地址分发资金。
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">发送方私钥 (单个)</label>
                            <input type="password" id="1n-key" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-sm focus:outline-none focus:border-primary" placeholder="支持格式: Base58, Hex, JSON Array">
                            <div class="mt-2 text-xs text-gray-500 flex justify-between items-center">
                                <span>* 为了安全，输入时隐藏</span>
                                <button onclick="verifyKeys('1n-key')" class="text-primary hover:underline text-xs flex items-center gap-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                                    </svg>
                                    查看余额
                                </button>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">批量接收地址 (每行一个)</label>
                            <textarea id="1n-addrs" rows="10" class="w-full bg-gray-800 border border-gray-600 rounded p-3 font-mono text-xs focus:outline-none focus:border-primary" placeholder="Solana地址 (Base58)"></textarea>
                             <button onclick="verifyKeys('1n-key')" class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 text-secondary text-sm rounded transition-colors flex justify-center items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                确认导入接收地址
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Common Settings -->
                <div class="mt-6 pt-6 border-t border-gray-700">
                    <!-- Account Overview Panel -->
                    <div id="account-overview-panel" class="mb-6 hidden">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-sm font-bold text-white flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
                                </svg>
                                账户概览 & 余额 (Account Overview)
                            </h3>
                            <button onclick="clearAccountOverview()" class="text-xs text-gray-500 hover:text-red-400">清空列表</button>
                        </div>
                        <div class="bg-gray-800/50 rounded border border-gray-700 overflow-hidden">
                            <div class="max-h-60 overflow-y-auto custom-scrollbar">
                                <table class="w-full text-left text-xs text-gray-400">
                                    <thead class="bg-gray-800 text-gray-300 uppercase font-medium sticky top-0 z-10">
                                        <tr>
                                            <th class="px-4 py-2">#</th>
                                            <th class="px-4 py-2">钱包地址 (Sender)</th>
                                            <th class="px-4 py-2">接收地址 (Receiver)</th>
                                            <th class="px-4 py-2">SOL余额</th>
                                            <th class="px-4 py-2">状态</th>
                                        </tr>
                                    </thead>
                                    <tbody id="account-table-body" class="divide-y divide-gray-700/50">
                                        <!-- Rows -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="flex flex-col md:flex-row gap-4 items-end">
                        <div class="flex-grow">
                            <label class="block text-sm font-medium text-gray-400 mb-1">转账数量设置</label>
                            
                            <!-- Mode Selection -->
                            <div class="flex gap-4 mb-2">
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="radio" name="amount-mode" value="all" class="form-radio text-primary bg-gray-800 border-gray-600 focus:ring-0" onclick="toggleAmountInputs()">
                                    <span class="ml-2 text-sm text-gray-300">全部</span>
                                </label>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="radio" name="amount-mode" value="percent" class="form-radio text-primary bg-gray-800 border-gray-600 focus:ring-0" onclick="toggleAmountInputs()">
                                    <span class="ml-2 text-sm text-gray-300">百分比</span>
                                </label>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="radio" name="amount-mode" value="random" class="form-radio text-primary bg-gray-800 border-gray-600 focus:ring-0" onclick="toggleAmountInputs()">
                                    <span class="ml-2 text-sm text-gray-300">随机</span>
                                </label>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="radio" name="amount-mode" value="fixed" class="form-radio text-primary bg-gray-800 border-gray-600 focus:ring-0" onclick="toggleAmountInputs()" checked>
                                    <span class="ml-2 text-sm text-gray-300">固定</span>
                                </label>
                            </div>

                            <!-- Input Fields -->
                            <div id="amount-input-container">
                                <div id="amount-fixed">
                                    <input type="number" id="amount" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary placeholder-gray-500" placeholder="0.1">
                                </div>
                                <div id="input-percent" class="hidden">
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="amount-percent" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary" placeholder="50">
                                        <span class="text-gray-400">%</span>
                                    </div>
                                </div>
                                <div id="input-random" class="hidden">
                                    <div class="flex gap-2 items-center">
                                        <input type="number" id="random-min" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary" placeholder="Min (0.01)">
                                        <span class="text-gray-400">-</span>
                                        <input type="number" id="random-max" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary" placeholder="Max (0.1)">
                                    </div>
                                </div>
                                <div id="input-all" class="hidden">
                                    <div class="w-full bg-gray-800/50 border border-gray-600 rounded px-3 py-2 text-gray-400 italic">
                                        将发送账户内所有可用余额 (保留Gas费)
                                    </div>
                                </div>
                            </div>
                        </div>

                         <!-- Delay Settings -->
                         <div class="w-full md:w-48">
                            <label class="block text-sm font-medium text-gray-400 mb-1">随机延迟 (秒)</label>
                            <div class="flex items-center gap-2">
                                <input type="number" id="delay-min" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary text-center" placeholder="0">
                                <span class="text-gray-500">-</span>
                                <input type="number" id="delay-max" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-primary text-center" placeholder="0">
                            </div>
                        </div>

                         <!-- Gas Estimate -->
                         <div class="w-full md:w-auto min-w-[180px]">
                            <label class="block text-sm font-medium text-gray-400 mb-1 flex justify-between">
                                <span>预估 Gas 费用</span>
                                <button onclick="updateGasEstimate()" class="text-xs text-primary hover:underline">刷新</button>
                            </label>
                            <div id="gas-price-display" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-sm font-mono flex items-center h-[42px] whitespace-nowrap overflow-hidden">
                                <span class="text-gray-500">Checking...</span>
                            </div>
                        </div>

                        <button onclick="confirmExecution()" class="w-full md:w-auto bg-primary hover:bg-blue-600 text-white font-bold py-2 px-6 rounded shadow-lg transform transition hover:scale-105 active:scale-95">
                            开始执行
                        </button>
                    </div>
                </div>
            </div>

            <!-- Logs -->
            <div class="bg-gray-900 border-t border-gray-700 p-4">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-bold text-gray-400">执行日志</h3>
                    <button onclick="exportLogs()" class="text-xs text-primary hover:underline">导出 CSV</button>
                </div>
                <div class="h-48 overflow-y-auto custom-scrollbar bg-black/30 rounded p-2 font-mono text-xs">
                    <table class="w-full text-left">
                        <thead>
                            <tr class="text-gray-500 border-b border-gray-700">
                                <th class="pb-1 w-12">#</th>
                                <th class="pb-1 w-24">Status</th>
                                <th class="pb-1">Details</th>
                            </tr>
                        </thead>
                        <tbody id="log-table-body" class="text-gray-300">
                            <!-- Logs -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>

    <!-- Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/80 hidden items-center justify-center z-50 backdrop-blur-sm">
        <div class="bg-cardbg border border-gray-600 rounded-lg p-6 max-w-md w-full shadow-2xl transform transition-all scale-100">
            <h3 class="text-xl font-bold text-white mb-4 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
                确认执行
            </h3>
            <div class="space-y-3 text-sm text-gray-300">
                <p>您即将执行以下批量操作：</p>
                <ul class="list-disc pl-5 space-y-1">
                    <li>模式: <span class="font-bold text-primary" id="modal-mode">-</span></li>
                    <li>任务数量: <span class="font-bold text-white" id="modal-count">0</span></li>
                    <li>单个金额: <span class="font-bold text-secondary" id="modal-amount">-</span></li>
                    <li>代币类型: <span class="font-bold text-blue-400" id="modal-token">SOL (Native)</span></li>
                </ul>
                <p class="mt-4 text-red-400 text-xs border border-red-500/30 bg-red-900/10 p-2 rounded">
                    ⚠️ 警告：区块链交易不可逆。请仔细核对接收地址和金额。
                    点击确认后将立即广播交易。
                </p>
            </div>
            <div class="mt-6 flex gap-3">
                <button onclick="closeModal()" class="flex-1 py-2 bg-gray-700 hover:bg-gray-600 rounded text-gray-300 transition-colors">
                    取消
                </button>
                <button onclick="executeTransfer()" class="flex-1 py-2 bg-primary hover:bg-blue-600 rounded text-white font-bold transition-colors shadow-lg">
                    确认并发送
                </button>
            </div>
        </div>
    </div>

    <script>
        // Solana Globals
        const { Connection, PublicKey, Keypair, SystemProgram, Transaction, sendAndConfirmTransaction, LAMPORTS_PER_SOL, TransactionInstruction } = solanaWeb3;

        // --- SPL Token Helper (Manual Implementation to avoid dependencies) ---
        const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
        const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

        const SplTokenHelper = {
            async getAssociatedTokenAddress(mint, owner) {
                const [address] = await PublicKey.findProgramAddress(
                    [owner.toBytes(), TOKEN_PROGRAM_ID.toBytes(), mint.toBytes()],
                    ASSOCIATED_TOKEN_PROGRAM_ID
                );
                return address;
            },

            createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint) {
                const keys = [
                    { pubkey: payer, isSigner: true, isWritable: true },
                    { pubkey: associatedToken, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: false, isWritable: false },
                    { pubkey: mint, isSigner: false, isWritable: false },
                    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                ];
                return new TransactionInstruction({
                    keys,
                    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                    data: new Uint8Array(0),
                });
            },

            createTransferInstruction(source, destination, owner, amount) {
                const keys = [
                    { pubkey: source, isSigner: false, isWritable: true },
                    { pubkey: destination, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: true, isWritable: false },
                ];
                
                // Layout: instruction (u8) 3 = Transfer, amount (u64)
                const data = new Uint8Array(9);
                const view = new DataView(data.buffer);
                view.setUint8(0, 3);
                view.setBigUint64(1, BigInt(amount), true); // Little Endian

                return new TransactionInstruction({
                    keys,
                    programId: TOKEN_PROGRAM_ID,
                    data,
                });
            }
        };

        // --- Metaplex Metadata Helper ---
        const METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
        const MetaplexHelper = {
            async getMetadataAddress(mint) {
                const [address] = await PublicKey.findProgramAddress(
                    [
                        new TextEncoder().encode('metadata'),
                        METADATA_PROGRAM_ID.toBytes(),
                        mint.toBytes()
                    ],
                    METADATA_PROGRAM_ID
                );
                return address;
            },

            decodeMetadata(data) {
                try {
                    const buffer = data instanceof Uint8Array ? data : new Uint8Array(data);
                    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                    
                    let offset = 0;
                    // Key (4 = MetadataV1)
                    if (buffer[0] !== 4) return null;
                    offset += 1;
                    
                    offset += 32; // update_authority
                    offset += 32; // mint
                    
                    // Name
                    const nameLen = view.getUint32(offset, true);
                    offset += 4;
                    const nameBytes = buffer.slice(offset, offset + nameLen);
                    const name = new TextDecoder().decode(nameBytes).replace(/\0/g, '').trim();
                    offset += nameLen;
                    
                    // Symbol
                    const symbolLen = view.getUint32(offset, true);
                    offset += 4;
                    const symbolBytes = buffer.slice(offset, offset + symbolLen);
                    const symbol = new TextDecoder().decode(symbolBytes).replace(/\0/g, '').trim();
                    
                    return { name, symbol };
                } catch (e) {
                    console.warn("Metadata decode error:", e);
                    return null;
                }
            }
        };

        const NETWORKS = {
            mainnet: "https://mainnet.helius-rpc.com/?api-key=236b88d9-ac4e-4da5-9361-c17b6b9661a4"
        };

        let currentTab = 'mn';
        let tasks = [];
        let isProcessing = false;
        let rpcMonitorInterval = null;
        let currentTokenDecimals = 9; // Default SOL
        let currentTokenMint = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            switchTab('mn');
            restartRpcMonitor();
            updateGasEstimate();
        });

        async function checkTokenInfo() {
            const input = document.getElementById('tokenAddress').value.trim();
            const infoDiv = document.getElementById('tokenInfo');
            const decimalsSpan = document.getElementById('tokenDecimals');

            if (!input) {
                currentTokenMint = null;
                currentTokenDecimals = 9;
                infoDiv.classList.add('hidden');
                return;
            }

            try {
                const mintPubkey = new PublicKey(input);
                const rpcUrl = document.getElementById('rpcUrl').value.trim();
                const connection = new Connection(rpcUrl);

                // Fetch Mint Info
                const info = await connection.getParsedAccountInfo(mintPubkey);
                
                // Check if it's a valid SPL Token Mint (Standard)
                // We currently only support the standard Token Program
                if (info.value && info.value.owner.toString() === TOKEN_PROGRAM_ID.toString()) {
                    if (info.value.data.parsed.info.decimals !== undefined) {
                        currentTokenMint = mintPubkey;
                        currentTokenDecimals = info.value.data.parsed.info.decimals;
                        
                        // Show basic info first
                        let displayText = `Decimals: ${currentTokenDecimals}`;
                        decimalsSpan.innerText = "Loading Metadata... | " + displayText;
                        infoDiv.classList.remove('hidden');
                        
                        // Try fetch metadata (Name/Symbol)
                        try {
                            const metadataPda = await MetaplexHelper.getMetadataAddress(mintPubkey);
                            const metadataAccount = await connection.getAccountInfo(metadataPda);
                            if (metadataAccount) {
                                const metadata = MetaplexHelper.decodeMetadata(metadataAccount.data);
                                if (metadata) {
                                    // Update with name and symbol
                                    displayText = `${metadata.symbol} (${metadata.name}) | Decimals: ${currentTokenDecimals}`;
                                }
                            }
                        } catch (e) {
                            console.warn("Metadata fetch failed", e);
                        }

                        decimalsSpan.innerText = displayText;
                        
                    } else {
                        throw new Error("Not a Mint Account");
                    }
                } else {
                     if (info.value) {
                         throw new Error(`Unsupported Program: ${info.value.owner.toString()}`);
                     }
                     throw new Error("Account not found");
                }
            } catch(e) {
                currentTokenMint = null;
                currentTokenDecimals = 9;
                decimalsSpan.innerText = "Invalid Token Address";
                infoDiv.classList.remove('hidden');
            }
        }

        function switchTab(tab) {
            currentTab = tab;
            ['mn', 'm1', '1n'].forEach(t => {
                document.getElementById(`tab-${t}`).classList.remove('border-primary', 'text-primary');
                document.getElementById(`tab-${t}`).classList.add('border-transparent', 'text-gray-400');
                document.getElementById(`panel-${t}`).classList.add('hidden');
            });
            document.getElementById(`tab-${tab}`).classList.add('border-primary', 'text-primary');
            document.getElementById(`tab-${tab}`).classList.remove('border-transparent', 'text-gray-400');
            document.getElementById(`panel-${tab}`).classList.remove('hidden');

            // Clear inputs
            clearAccountOverview();
            
            // Clear textareas/inputs in all tabs
            ['mn-keys', 'mn-addrs', 'm1-keys', 'm1-addr', '1n-key', '1n-addrs'].forEach(id => {
                const el = document.getElementById(id);
                if(el) el.value = '';
            });

            // Reset Amount Mode to Fixed
            const fixedRadio = document.querySelector('input[name="amount-mode"][value="fixed"]');
            if (fixedRadio) {
                fixedRadio.checked = true;
                toggleAmountInputs();
            }
            
            // Clear Amount inputs
             ['amount', 'amount-percent', 'random-min', 'random-max', 'delay-min', 'delay-max'].forEach(id => {
                const el = document.getElementById(id);
                if(el) el.value = '';
            });
            
            // Clear Token
            document.getElementById('tokenAddress').value = '';
            checkTokenInfo();
        }

        function toggleAmountInputs() {
            const modes = document.getElementsByName('amount-mode');
            let selected;
            for(let m of modes) { if(m.checked) selected = m.value; }
            
            document.getElementById('amount-fixed').classList.add('hidden');
            document.getElementById('input-percent').classList.add('hidden');
            document.getElementById('input-random').classList.add('hidden');
            document.getElementById('input-all').classList.add('hidden');

            if(selected === 'fixed') document.getElementById('amount-fixed').classList.remove('hidden');
            if(selected === 'percent') document.getElementById('input-percent').classList.remove('hidden');
            if(selected === 'random') document.getElementById('input-random').classList.remove('hidden');
            if(selected === 'all') document.getElementById('input-all').classList.remove('hidden');
        }

        function onNetworkChange() {
            const select = document.getElementById('networkSelect');
            const rpcInput = document.getElementById('rpcUrl');
            
            if (select.value === 'custom') {
                rpcInput.value = '';
                rpcInput.focus();
            } else {
                rpcInput.value = NETWORKS[select.value];
            }
            restartRpcMonitor();
            updateGasEstimate();
        }

        function restartRpcMonitor() {
            if (rpcMonitorInterval) clearInterval(rpcMonitorInterval);
            checkRpcStatus();
            rpcMonitorInterval = setInterval(checkRpcStatus, 10000);
        }

        async function checkRpcStatus() {
            const rpcUrl = document.getElementById('rpcUrl').value.trim();
            const statusEl = document.getElementById('rpcStatus');
            const latencyEl = document.getElementById('rpcLatency');
            const heightEl = document.getElementById('rpcHeight');

            if (!rpcUrl) {
                statusEl.innerHTML = '<span class="w-2 h-2 rounded-full bg-red-500"></span><span>请输入RPC</span>';
                return;
            }

            const start = Date.now();
            try {
                const connection = new Connection(rpcUrl);
                const blockHeight = await connection.getSlot();
                const latency = Date.now() - start;

                statusEl.innerHTML = '<span class="w-2 h-2 rounded-full bg-green-500"></span><span class="text-green-400">正常</span>';
                latencyEl.innerText = `${latency}ms`;
                latencyEl.classList.remove('hidden');
                heightEl.innerText = `#${blockHeight}`;
                heightEl.classList.remove('hidden');
            } catch (e) {
                statusEl.innerHTML = `<span class="w-2 h-2 rounded-full bg-red-500"></span><span class="text-red-400" title="${e.message}">连接失败</span>`;
                latencyEl.classList.add('hidden');
                heightEl.classList.add('hidden');
            }
        }

        async function updateGasEstimate() {
            const display = document.getElementById('gas-price-display');
            if (!display) return;
            display.innerText = "Updating...";
            
            // Add slight delay for visual feedback
            await new Promise(r => setTimeout(r, 500));

            try {
                const rpcUrl = document.getElementById('rpcUrl').value.trim();
                if (!rpcUrl) {
                    display.innerText = "No RPC URL";
                    return;
                }
                
                // Simple estimate for Solana: usually 5000 lamports per signature
                // Dynamic fees exist, but 5000 is base.
                const costLamports = 5000; 
                const costSol = costLamports / LAMPORTS_PER_SOL;

                display.innerHTML = `<span class="text-yellow-400">Base Fee</span><span class="mx-2 text-gray-500">|</span><span class="text-green-400">~${costSol.toFixed(6)} SOL</span>`;
                
            } catch (e) {
                console.error(e);
                display.innerText = "Gas Check Failed";
            }
        }

        function parseInput(input) {
            return input.split('\n').map(l => l.trim()).filter(l => l);
        }

        function clearAccountOverview() {
             document.getElementById('account-overview-panel').classList.add('hidden');
             document.getElementById('account-table-body').innerHTML = '';
             tasks = [];
        }

        function updateLogTable() {
            const tbody = document.getElementById('log-table-body');
            tbody.innerHTML = '';
            
            tasks.slice().reverse().forEach((task, index) => {
                const realIndex = tasks.length - 1 - index;
                let statusColor = 'text-gray-400';
                if (task.status === 'Success') statusColor = 'text-green-400';
                if (task.status === 'Failed') statusColor = 'text-red-400';
                if (task.status === 'Sending') statusColor = 'text-yellow-400';

                const tr = document.createElement('tr');
                tr.className = 'border-b border-gray-800 hover:bg-white/5 transition-colors';
                tr.innerHTML = `
                    <td class="py-2 text-gray-500">${realIndex + 1}</td>
                    <td class="py-2 ${statusColor} font-bold">${task.status}</td>
                    <td class="py-2 text-gray-400 break-all">
                        <div class="flex flex-col">
                            <span>${task.details}</span>
                            ${task.hash ? `<a href="https://solscan.io/tx/${task.hash}" target="_blank" class="text-primary hover:underline text-[10px]">${task.hash}</a>` : ''}
                        </div>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- Core Logic ---

        // Base58 Helper
        const Base58 = {
            decode(string) {
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                const ALPHABET_MAP = {};
                for(let i = 0; i < ALPHABET.length; i++) ALPHABET_MAP[ALPHABET.charAt(i)] = i;
                if (string.length === 0) return new Uint8Array(0);
                let i, j, bytes = [0];
                for (i = 0; i < string.length; i++) {
                    const c = string[i];
                    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');
                    for (j = 0; j < bytes.length; j++) bytes[j] *= 58;
                    bytes[0] += ALPHABET_MAP[c];
                    let carry = 0;
                    for (j = 0; j < bytes.length; ++j) {
                        bytes[j] += carry;
                        carry = bytes[j] >> 8;
                        bytes[j] &= 0xff;
                    }
                    while (carry) {
                        bytes.push(carry & 0xff);
                        carry >>= 8;
                    }
                }
                if (bytes.length === 1 && bytes[0] === 0) bytes = [];
                for (i = 0; i < string.length && string[i] === '1'; i++) bytes.push(0);
                return new Uint8Array(bytes.reverse());
            }
        };

        // Helper to decode private key
        function decodePrivateKey(input) {
            try {
                input = input.trim();
                
                // 1. Try JSON array
                if (input.startsWith('[') && input.endsWith(']')) {
                    const arr = JSON.parse(input);
                    return Keypair.fromSecretKey(new Uint8Array(arr));
                }
                
                // 2. Try Hex String (64 chars = 32 bytes seed, 128 chars = 64 bytes secret)
                const hexRegex = /^[0-9a-fA-F]+$/;
                if (hexRegex.test(input)) {
                    if (input.length === 64) {
                        // 32 bytes Seed
                        const bytes = new Uint8Array(input.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                        return Keypair.fromSeed(bytes);
                    } else if (input.length === 128) {
                        // 64 bytes Secret Key
                        const bytes = new Uint8Array(input.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                        try {
                            return Keypair.fromSecretKey(bytes);
                        } catch (e) {
                            return Keypair.fromSeed(bytes.slice(0, 32));
                        }
                    }
                }

                // 3. Try Base58
                const decoded = Base58.decode(input);
                if (decoded.length === 32) {
                    return Keypair.fromSeed(decoded);
                }
                if (decoded.length === 64) {
                    try {
                        return Keypair.fromSecretKey(decoded);
                    } catch (e) {
                        // Fallback: If public key validation fails, derive from seed (first 32 bytes)
                        return Keypair.fromSeed(decoded.slice(0, 32));
                    }
                }
                return Keypair.fromSecretKey(decoded);
            } catch (e) {
                return null;
            }
        }

        async function verifyKeys(sourceId) {
            clearAccountOverview();
            const keysInput = document.getElementById(sourceId).value;
            const keyLines = parseInput(keysInput);
            
            if (keyLines.length === 0) {
                alert("请输入私钥");
                return;
            }

            const rpcUrl = document.getElementById('rpcUrl').value.trim();
            const connection = new Connection(rpcUrl);
            
            // Pre-flight RPC check
            try {
                await connection.getSlot();
            } catch(e) {
                alert(`RPC连接失败: ${e.message}\n请检查RPC节点地址是否正确或网络是否通畅。`);
                return;
            }

            const tbody = document.getElementById('account-table-body');
            tbody.innerHTML = '';
            document.getElementById('account-overview-panel').classList.remove('hidden');

            tasks = [];
            
            // Process Keys
            for (let i = 0; i < keyLines.length; i++) {
                const line = keyLines[i];
                let keypair = decodePrivateKey(line);
                let address = keypair ? keypair.publicKey.toBase58() : "Invalid Key";
                let shortAddr = address.slice(0, 6) + '...' + address.slice(-4);
                let balance = '...';
                let status = keypair ? 'Valid' : 'Invalid';
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-4 py-2 text-gray-500">${i + 1}</td>
                    <td class="px-4 py-2 font-mono text-white" title="${address}">${shortAddr}</td>
                    <td class="px-4 py-2 font-mono text-white" id="row-recv-${i}">-</td>
                    <td class="px-4 py-2 text-yellow-400" id="row-bal-${i}">Loading...</td>
                    <td class="px-4 py-2 ${keypair ? 'text-green-400' : 'text-red-400'}">${status}</td>
                `;
                tbody.appendChild(tr);

                if (keypair) {
                    tasks.push({
                        index: i,
                        key: line, // store original input
                        keypair: keypair,
                        sender: address,
                        receiver: '',
                        amount: '',
                        status: 'Pending',
                        details: 'Initialized',
                        balance: 0, // Lamports
                        tokenBalance: 0n // Raw Token Amount
                    });

                    // Async fetch balance
                    const pSol = connection.getBalance(keypair.publicKey);
                    let pToken = Promise.resolve(null);

                    if (currentTokenMint) {
                         pToken = connection.getParsedTokenAccountsByOwner(keypair.publicKey, { mint: currentTokenMint });
                    }

                    Promise.all([pSol, pToken]).then(([bal, tokenAccounts]) => {
                        const solBal = bal / LAMPORTS_PER_SOL;
                        tasks[i].balance = bal;

                        let displayStr = solBal.toFixed(4) + " SOL";
                        
                        if (tokenAccounts) {
                            let tBal = 0n;
                            if (tokenAccounts.value.length > 0) {
                                // Sum up if multiple accounts (unlikely for ATA but possible)
                                tokenAccounts.value.forEach(acc => {
                                    tBal += BigInt(acc.account.data.parsed.info.tokenAmount.amount);
                                });
                            }
                            tasks[i].tokenBalance = tBal;
                            
                            // Format Token Balance
                            const tHuman = Number(tBal) / Math.pow(10, currentTokenDecimals);
                            displayStr = `${tHuman.toFixed(4)} Token | ${solBal.toFixed(4)} SOL`;
                        }

                        document.getElementById(`row-bal-${i}`).innerText = displayStr;
                    }).catch(e => {
                        console.error(e);
                        document.getElementById(`row-bal-${i}`).innerText = "Error";
                    });
                } else {
                    tasks.push({
                        index: i,
                        status: 'Failed',
                        details: 'Invalid Private Key Format'
                    });
                }
            }
        }

        function verifyMnMapping() {
            // Check receivers for MN mode
            const addrInput = document.getElementById('mn-addrs').value;
            const addrLines = parseInput(addrInput);

            if (tasks.length === 0) {
                alert("请先导入私钥");
                return;
            }

            if (addrLines.length !== tasks.length) {
                alert(`数量不匹配! 私钥: ${tasks.length} 行, 地址: ${addrLines.length} 行`);
                return;
            }

            addrLines.forEach((addr, i) => {
                if (tasks[i] && tasks[i].status !== 'Failed') {
                    tasks[i].receiver = addr;
                    document.getElementById(`row-recv-${i}`).innerText = addr.slice(0, 6) + '...' + addr.slice(-4);
                }
            });
            // alert("接收地址已映射");
        }

        function verifyM1Mapping() {
            // Check receiver for M1 mode
            const addr = document.getElementById('m1-addr').value.trim();
            
            if (!addr) {
                alert("请输入接收地址");
                return;
            }

            try {
                new PublicKey(addr);
            } catch (e) {
                alert("无效的 Solana 地址");
                return;
            }

            if (tasks.length === 0) {
                alert("请先导入私钥");
                return;
            }

            // Apply to all tasks
            tasks.forEach((task, i) => {
                if (task.status !== 'Failed') {
                    task.receiver = addr;
                    document.getElementById(`row-recv-${i}`).innerText = addr.slice(0, 6) + '...' + addr.slice(-4);
                }
            });

            // alert("接收地址已设置");
        }

        async function prepareTasks(checkBalanceOnly) {
            const rpcUrl = document.getElementById('rpcUrl').value.trim();
            const connection = new Connection(rpcUrl);

            // Get Receiver logic
            let globalReceiver = '';
            if (currentTab === 'm1') {
                globalReceiver = document.getElementById('m1-addr').value.trim();
                if (!globalReceiver) {
                    if (!checkBalanceOnly) alert("请输入接收地址");
                    return false;
                }
            } else if (currentTab === '1n') {
                // 1:N Logic is specific: Single Sender, Multi Receivers
                // We need to reconstruct tasks based on 1N inputs
                const senderKey = document.getElementById('1n-key').value.trim();
                const keypair = decodePrivateKey(senderKey);
                if (!keypair) {
                    if (!checkBalanceOnly) alert("发送方私钥无效");
                    return false;
                }
                
                const addrInput = document.getElementById('1n-addrs').value;
                const addrLines = parseInput(addrInput);
                if (addrLines.length === 0) {
                     if (!checkBalanceOnly) alert("请输入接收地址列表");
                     return false;
                }

                tasks = []; // Reset tasks for 1N
                const senderAddr = keypair.publicKey.toBase58();
                
                // Fetch sender balance once
                let senderBalance = 0;
                try {
                    senderBalance = await connection.getBalance(keypair.publicKey);
                } catch(e) {
                     if (!checkBalanceOnly) alert("无法获取发送方余额");
                     return false;
                }

                addrLines.forEach((addr, i) => {
                    tasks.push({
                        index: i,
                        key: senderKey,
                        keypair: keypair,
                        sender: senderAddr,
                        receiver: addr,
                        status: 'Pending',
                        details: 'Prepared',
                        balance: senderBalance // Shared balance, caution in calc
                    });
                });
            }

            // Get Amount Logic
            let amountData = {};
            const modes = document.getElementsByName('amount-mode');
            for(let m of modes) { if(m.checked) amountData.mode = m.value; }
            
            if (amountData.mode === 'fixed') amountData.value = document.getElementById('amount').value;
            if (amountData.mode === 'percent') amountData.value = document.getElementById('amount-percent').value;
            if (amountData.mode === 'random') {
                amountData.min = document.getElementById('random-min').value;
                amountData.max = document.getElementById('random-max').value;
            }

            if (!checkBalanceOnly) {
                if (amountData.mode !== 'all' && !amountData.value && !amountData.min) {
                    alert("请设置转账金额");
                    return false;
                }
            }

            // Iterate and validate
            for (let task of tasks) {
                if (task.status === 'Failed') continue;
                
                if (currentTab === 'm1') task.receiver = globalReceiver;
                if (currentTab === 'mn' && !task.receiver) {
                    task.status = 'Failed';
                    task.details = 'Missing Receiver';
                    continue;
                }
                
                // Validate Receiver Address
                try {
                    new PublicKey(task.receiver);
                } catch(e) {
                    task.status = 'Failed';
                    task.details = 'Invalid Receiver Address';
                    continue;
                }

                task.amountData = amountData; // Store for execution

                // Balance Check & Estimation
                const balance = task.balance || 0; // SOL Balance (Lamports)
                const balanceBig = BigInt(balance);
                const fee = 5000n; // Base fee
                const safeFee = 10000n; // Buffer

                let amountRaw = 0n; // This is either Lamports or Token Units

                if (currentTokenMint) {
                    // --- SPL Token Logic ---
                    const tBalance = task.tokenBalance || 0n;
                    const decimals = currentTokenDecimals;
                    const power = BigInt(Math.pow(10, decimals));

                    if (amountData.mode === 'all') {
                        amountRaw = tBalance;
                        task.amount = "MAX Token (" + (Number(tBalance)/Number(power)).toFixed(4) + ")";
                    } else if (amountData.mode === 'percent') {
                        amountRaw = tBalance * BigInt(Math.floor(parseFloat(amountData.value))) / 100n;
                        task.amount = amountData.value + "% Token (" + (Number(amountRaw)/Number(power)).toFixed(4) + ")";
                    } else if (amountData.mode === 'random') {
                        // Approximate for tokens
                        const min = parseFloat(amountData.min);
                        const max = parseFloat(amountData.max);
                        const rand = Math.random() * (max - min) + min;
                        amountRaw = BigInt(Math.floor(rand * Math.pow(10, decimals)));
                        task.amount = "Random Token (~" + rand.toFixed(4) + ")";
                    } else {
                        amountRaw = BigInt(Math.floor(parseFloat(amountData.value) * Math.pow(10, decimals)));
                        task.amount = amountData.value + " Token";
                    }

                    if (checkBalanceOnly) {
                        if (tBalance < amountRaw) {
                            task.status = 'Failed';
                            task.details = 'Insufficient Token Balance';
                        } else if (balanceBig < safeFee) {
                             task.status = 'Failed';
                             task.details = 'Insufficient SOL for Gas';
                        } else {
                            task.status = 'Ready';
                            task.details = 'Balance OK';
                        }
                    }

                } else {
                    // --- Native SOL Logic ---
                    if (amountData.mode === 'all') {
                        if (balanceBig <= safeFee) {
                            if (checkBalanceOnly) {
                                 task.status = 'Failed'; task.details = 'Insufficient SOL for Gas';
                            }
                        } else {
                            amountRaw = balanceBig - safeFee;
                            task.amount = "MAX (~" + (Number(amountRaw)/LAMPORTS_PER_SOL).toFixed(5) + ")";
                        }
                    } else if (amountData.mode === 'percent') {
                        const available = balanceBig > safeFee ? balanceBig - safeFee : 0n;
                        amountRaw = available * BigInt(Math.floor(parseFloat(amountData.value))) / 100n;
                        task.amount = amountData.value + "% (~" + (Number(amountRaw)/LAMPORTS_PER_SOL).toFixed(5) + ")";
                    } else if (amountData.mode === 'random') {
                        const min = parseFloat(amountData.min);
                        const max = parseFloat(amountData.max);
                        const rand = Math.random() * (max - min) + min;
                        amountRaw = BigInt(Math.floor(rand * LAMPORTS_PER_SOL));
                        task.amount = "Random (~" + rand.toFixed(4) + ")";
                    } else {
                        amountRaw = BigInt(Math.floor(parseFloat(amountData.value) * LAMPORTS_PER_SOL));
                        task.amount = amountData.value;
                    }

                    if (checkBalanceOnly) {
                        if (balanceBig < amountRaw + fee) {
                            task.status = 'Failed';
                            task.details = 'Insufficient Balance';
                        } else {
                            task.status = 'Ready';
                            task.details = 'Balance OK';
                        }
                    }
                }
            }

            if (checkBalanceOnly) {
                updateLogTable();
            }
            return true;
        }

        async function checkBalances() {
            if (isProcessing) return;
            isProcessing = true;
            await prepareTasks(true);
            isProcessing = false;
        }

        function openModal() {
            document.getElementById('confirm-modal').classList.remove('hidden');
            document.getElementById('confirm-modal').classList.add('flex');
        }

        function closeModal() {
            document.getElementById('confirm-modal').classList.add('hidden');
            document.getElementById('confirm-modal').classList.remove('flex');
        }

        async function confirmExecution() {
            const ready = await prepareTasks(false);
            if (!ready) return;

            const validCount = tasks.filter(t => t.status !== 'Failed').length; // Logic differs slightly, we assume non-failed are ready to try
            if (validCount === 0) {
                alert("没有有效的待处理任务");
                return;
            }

            document.getElementById('modal-mode').innerText = currentTab.toUpperCase();
            document.getElementById('modal-count').innerText = validCount;
            document.getElementById('modal-amount').innerText = tasks[0].amount; // Display first task amount as example

            openModal();
        }

        async function executeTransfer() {
            closeModal();
            if (isProcessing) return;
            isProcessing = true;

            const rpcUrl = document.getElementById('rpcUrl').value.trim();
            const connection = new Connection(rpcUrl, 'confirmed');

            // --- Optimization & Caching ---
            // 1. Blockhash Cache: Reuse blockhash for 30s to reduce RPC calls
            let cachedBlockhash = null;
            let cachedBlockhashTime = 0;
            const BLOCKHASH_TTL = 30000; // 30s

            // 2. Rent Cache: Fetch once
            let cachedRentExemption = null;

            // Retry Helper with Exponential Backoff & 403 Handling
            const wait = (ms) => new Promise(r => setTimeout(r, ms));
            const retryOperation = async (fn, retries = 3, baseDelay = 1000) => {
                for (let i = 0; i < retries; i++) {
                    try {
                        return await fn();
                    } catch (e) {
                        let isLimitError = false;
                        if (e.message && (e.message.includes('403') || e.message.includes('429'))) {
                             isLimitError = true;
                        }
                        
                        if (i === retries - 1) throw e;
                        
                        let delay = baseDelay * Math.pow(2, i); // Exponential: 1s, 2s, 4s...
                        if (isLimitError) {
                            console.warn(`RPC Limit hit (403/429). Pausing for 5s...`);
                            delay = 5000; // Force 5s wait on limit error
                        }
                        
                        console.warn(`Retry ${i + 1}/${retries} failed: ${e.message}. Retrying in ${delay}ms...`);
                        await wait(delay);
                    }
                }
            };

            let processedCount = 0;
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                if (task.status === 'Failed') continue;

                // --- Mandatory Rate Limit Protection ---
                // Even without user delay, we enforce a gap to prevent 403
                const minGap = 2000; // Increased to 2s minimum gap
                
                // Random Delay logic
                let delaySec = 0;
                if (processedCount > 0) {
                    const delayMin = parseFloat(document.getElementById('delay-min').value) || 0;
                    const delayMax = parseFloat(document.getElementById('delay-max').value) || 0;
                    if (delayMax > 0 && delayMax >= delayMin) {
                        delaySec = Math.random() * (delayMax - delayMin) + delayMin;
                    }
                }
                
                // Ensure at least minGap if processedCount > 0
                if (processedCount > 0) {
                    const finalDelayMs = Math.max(delaySec * 1000, minGap);
                    task.details = `Waiting ${(finalDelayMs/1000).toFixed(1)}s...`;
                    updateLogTable();
                    await wait(finalDelayMs);
                }
                
                processedCount++;

                task.status = 'Sending';
                task.details = 'Building Tx...';
                updateLogTable();

                try {
                    // OPTIMIZATION: Removed redundant getBalance call.
                    // We rely on prepareTasks() or previous checks.
                    // If balance is insufficient, sendTransaction simulation (or on-chain) will fail.
                    // This saves 1 RPC call per task.
                    
                    const balanceBig = BigInt(task.balance || 0); // Use cached balance from prepare
                    const fee = 5000n; // Base fee
                    
                    let amountRaw = 0n;
                    let transaction = new Transaction();

                    // --- Blockhash Logic with Cache ---
                    const now = Date.now();
                    if (!cachedBlockhash || (now - cachedBlockhashTime > BLOCKHASH_TTL)) {
                        const { blockhash, lastValidBlockHeight } = await retryOperation(async () => {
                            return await connection.getLatestBlockhash('finalized');
                        }, 5, 2000);
                        cachedBlockhash = { blockhash, lastValidBlockHeight };
                        cachedBlockhashTime = now;
                    }
                    
                    transaction.recentBlockhash = cachedBlockhash.blockhash;
                    transaction.feePayer = task.keypair.publicKey;

                    if (currentTokenMint) {
                        // --- SPL Token Execution ---
                        const decimals = currentTokenDecimals;
                        
                        // Get Token Balance
                        const tokenAccounts = await retryOperation(() => connection.getParsedTokenAccountsByOwner(task.keypair.publicKey, { mint: currentTokenMint }), 3, 1000);
                        let tBalance = 0n;
                        if (tokenAccounts.value.length > 0) {
                            tokenAccounts.value.forEach(acc => {
                                tBalance += BigInt(acc.account.data.parsed.info.tokenAmount.amount);
                            });
                        }

                        if (task.amountData.mode === 'all') {
                             amountRaw = tBalance;
                        } else if (task.amountData.mode === 'percent') {
                             amountRaw = tBalance * BigInt(Math.floor(parseFloat(task.amountData.value))) / 100n;
                        } else if (task.amountData.mode === 'random') {
                            const min = parseFloat(task.amountData.min);
                            const max = parseFloat(task.amountData.max);
                            const rand = Math.random() * (max - min) + min;
                            amountRaw = BigInt(Math.floor(rand * Math.pow(10, decimals)));
                        } else {
                            amountRaw = BigInt(Math.floor(parseFloat(task.amountData.value) * Math.pow(10, decimals)));
                        }

                        if (amountRaw <= 0n) throw new Error("Token Amount too low");
                        if (balanceBig < fee) throw new Error("Insufficient SOL for Fee"); // Need SOL for fee

                        // ATA Derivation
                        const sourceATA = await SplTokenHelper.getAssociatedTokenAddress(currentTokenMint, task.keypair.publicKey);
                        const destPubkey = new PublicKey(task.receiver);
                        const destATA = await SplTokenHelper.getAssociatedTokenAddress(currentTokenMint, destPubkey);

                        // Check if Dest ATA exists
                        const destInfo = await retryOperation(() => connection.getAccountInfo(destATA), 3, 1000);
                        if (!destInfo) {
                            // Create ATA Instruction
                            task.details = "Creating ATA & Sending...";
                            updateLogTable();
                            
                            // Check if sender has enough SOL for Rent (~0.002039 SOL) + Fee
                            if (cachedRentExemption === null) {
                                cachedRentExemption = await retryOperation(() => connection.getMinimumBalanceForRentExemption(165), 3, 1000);
                            }
                            
                            if (balanceBig < fee + BigInt(cachedRentExemption)) {
                                throw new Error("Insufficient SOL for ATA Rent + Fee");
                            }

                            transaction.add(SplTokenHelper.createAssociatedTokenAccountInstruction(
                                task.keypair.publicKey,
                                destATA,
                                destPubkey,
                                currentTokenMint
                            ));
                        }

                        // Transfer Instruction
                        transaction.add(SplTokenHelper.createTransferInstruction(
                            sourceATA,
                            destATA,
                            task.keypair.publicKey,
                            amountRaw
                        ));

                    } else {
                        // --- Native SOL Execution ---
                        // ... (same as before)
                        if (task.amountData.mode === 'all') {
                            if (balanceBig <= fee) throw new Error("Insufficient SOL for Fee");
                            amountRaw = balanceBig - fee; 
                        } else if (task.amountData.mode === 'percent') {
                             const available = balanceBig > fee ? balanceBig - fee : 0n;
                             amountRaw = available * BigInt(Math.floor(parseFloat(task.amountData.value))) / 100n;
                        } else if (task.amountData.mode === 'random') {
                            const min = parseFloat(task.amountData.min);
                            const max = parseFloat(task.amountData.max);
                            const rand = Math.random() * (max - min) + min;
                            amountRaw = BigInt(Math.floor(rand * LAMPORTS_PER_SOL));
                        } else {
                            amountRaw = BigInt(Math.floor(parseFloat(task.amountData.value) * LAMPORTS_PER_SOL));
                        }

                        if (amountRaw <= 0n) throw new Error("Amount too low");
                        if (balanceBig < amountRaw + fee) throw new Error("Insufficient Funds");

                        transaction.add(
                            SystemProgram.transfer({
                                fromPubkey: task.keypair.publicKey,
                                toPubkey: new PublicKey(task.receiver),
                                lamports: amountRaw,
                            })
                        );
                    }

                    task.details = 'Signing...';
                    updateLogTable();

                    // Send with Retry
                    let signature = '';
                    
                    await retryOperation(async () => {
                         // Skip Preflight to save RPC calls and avoid simulation limits
                         signature = await connection.sendTransaction(transaction, [task.keypair], { skipPreflight: true, preflightCommitment: 'confirmed' });
                         task.hash = signature; // Store hash immediately after send
                    }, 3, 2000);

                    task.details = 'Confirming...';
                    updateLogTable();

                    // Confirm
                    const confirmation = await retryOperation(async () => {
                         return await connection.confirmTransaction({
                             signature,
                             blockhash: cachedBlockhash.blockhash,
                             lastValidBlockHeight: cachedBlockhash.lastValidBlockHeight
                         }, 'confirmed');
                    }, 3, 2000);

                    if (confirmation.value.err) {
                        throw new Error("Tx Error: " + JSON.stringify(confirmation.value.err));
                    }

                    task.status = 'Success';
                    task.details = 'Confirmed';
                    task.hash = signature;

                } catch (e) {
                    console.error(e);
                    
                    // --- False Positive Check for "Block Height Exceeded" ---
                    let isFalseFailure = false;
                    let signature = task.hash || ''; // Try to get signature if it was set before error
                    
                    // If we have a signature but failed with "block height exceeded" or similar
                    if (signature && (e.message.includes('block height exceeded') || e.message.includes('expired'))) {
                         task.details = 'Checking Status...';
                         updateLogTable();
                         try {
                             console.log("Checking signature status for expired tx:", signature);
                             // Wait a bit for propagation
                             await wait(2000); 
                             const status = await connection.getSignatureStatus(signature);
                             if (status && status.value && (status.value.confirmationStatus === 'confirmed' || status.value.confirmationStatus === 'finalized')) {
                                 if (!status.value.err) {
                                     isFalseFailure = true;
                                     task.status = 'Success';
                                     task.details = 'Confirmed (Recovered)';
                                 }
                             }
                         } catch(checkErr) {
                             console.warn("Failed to double-check tx status:", checkErr);
                         }
                    }

                    if (!isFalseFailure) {
                        task.status = 'Failed';
                        let msg = e.message || "Tx Failed";
                        if (msg.includes('403')) msg = "RPC Limit (403) - Retry Later";
                        task.details = msg;
                    }
                }
                updateLogTable();
            }

            isProcessing = false;
            // alert("批量转账执行完毕！");
        }

        function exportLogs() {
            if (tasks.length === 0) {
                alert("没有数据可导出");
                return;
            }
            
            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Index,Sender,Receiver,Amount,Status,Details,Hash\n";
            
            tasks.forEach((task, index) => {
                const row = [
                    index + 1,
                    task.sender,
                    task.receiver,
                    task.amount,
                    task.status,
                    task.details.replace(/,/g, ' '),
                    task.hash || ''
                ].join(",");
                csvContent += row + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "sol_transfer_logs.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

    </script>
</body>
</html>